-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package servant
@version 0.2

module Servant.Common.BaseUrl

-- | URI scheme to use
data Scheme

-- | http://
Http :: Scheme

-- | https://
Https :: Scheme

-- | Simple data type to represent the target of HTTP requests for
--   servant's automatically-generated clients.
data BaseUrl
BaseUrl :: Scheme -> String -> Int -> BaseUrl

-- | URI scheme to use
baseUrlScheme :: BaseUrl -> Scheme

-- | host (eg "haskell.org")
baseUrlHost :: BaseUrl -> String

-- | port (eg 80)
baseUrlPort :: BaseUrl -> Int
showBaseUrl :: BaseUrl -> String
parseBaseUrl :: String -> Either String BaseUrl
instance Show Scheme
instance Eq Scheme
instance Ord Scheme
instance Generic Scheme
instance Show BaseUrl
instance Eq BaseUrl
instance Ord BaseUrl
instance Generic BaseUrl
instance Datatype D1Scheme
instance Constructor C1_0Scheme
instance Constructor C1_1Scheme
instance Datatype D1BaseUrl
instance Constructor C1_0BaseUrl
instance Selector S1_0_0BaseUrl
instance Selector S1_0_1BaseUrl
instance Selector S1_0_2BaseUrl

module Servant.Common.Req
data Req
Req :: String -> QueryText -> ByteString -> Req
reqPath :: Req -> String
qs :: Req -> QueryText
reqBody :: Req -> ByteString
defReq :: Req
appendToPath :: String -> Req -> Req
appendToQueryString :: Text -> Maybe Text -> Req -> Req
setRQBody :: ByteString -> Req -> Req
reqToRequest :: (Functor m, MonadThrow m) => Req -> BaseUrl -> m Request
__manager :: MVar Manager
__withGlobalManager :: (Manager -> IO a) -> IO a
displayHttpRequest :: Method -> String
performRequest :: Method -> Req -> (Int -> Bool) -> BaseUrl -> EitherT String IO (Int, ByteString)
performRequestJSON :: FromJSON result => Method -> Req -> Int -> BaseUrl -> EitherT String IO result
catchStatusCodeException :: IO a -> IO (Either Status a)

-- | Like <a>decode</a> but allows all JSON values instead of just objects
--   and arrays.
decodeLenient :: FromJSON a => ByteString -> Either String a

module Servant.Common.Text

-- | For getting values from url captures and query string parameters
class FromText a
fromText :: FromText a => Text -> Maybe a

-- | For putting values in paths and query string parameters
class ToText a
toText :: ToText a => a -> Text
instance ToText Float
instance FromText Float
instance ToText Double
instance FromText Double
instance ToText Integer
instance FromText Integer
instance ToText Word64
instance FromText Word64
instance ToText Word32
instance FromText Word32
instance ToText Word16
instance FromText Word16
instance ToText Word8
instance FromText Word8
instance ToText Word
instance FromText Word
instance ToText Int64
instance FromText Int64
instance ToText Int32
instance FromText Int32
instance ToText Int16
instance FromText Int16
instance ToText Int8
instance FromText Int8
instance ToText Int
instance FromText Int
instance ToText Bool
instance FromText Bool
instance ToText String
instance FromText String
instance ToText Text
instance FromText Text


-- | This module lets you get API docs for free. It lets generate an
--   <a>API</a> from the type that represents your API using <a>docs</a>:
--   
--   <pre>
--   docs :: <a>HasDocs</a> api =&gt; <a>Proxy</a> api -&gt; <a>API</a>
--   </pre>
--   
--   You can then call <a>markdown</a> on it:
--   
--   <pre>
--   printMarkdown :: <a>API</a> -&gt; String
--   </pre>
--   
--   or define a custom pretty printer:
--   
--   <pre>
--   yourPrettyDocs :: <a>API</a> -&gt; String -- or blaze-html's HTML, or ...
--   </pre>
--   
--   The only thing you'll need to do will be to implement some classes for
--   your captures, get parameters and request or response bodies.
--   
--   Here's a little (but complete) example that you can run to see the
--   markdown pretty printer in action:
--   
--   <pre>
--   {-# LANGUAGE DataKinds #-}
--   {-# LANGUAGE PolyKinds #-}
--   {-# LANGUAGE TypeFamilies #-}
--   {-# LANGUAGE DeriveGeneric #-}
--   {-# LANGUAGE TypeOperators #-}
--   {-# LANGUAGE FlexibleInstances #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Data.Proxy
--   import Data.Text
--   import Servant
--   
--   -- our type for a Greeting message
--   data Greet = Greet { _msg :: Text }
--     deriving (Generic, Show)
--   
--   -- we get our JSON serialization for free
--   instance FromJSON Greet
--   instance ToJSON Greet
--   
--   -- we provide a sample value for the 'Greet' type
--   instance ToSample Greet where
--     toSample = Just g
--   
--       where g = Greet "Hello, haskeller!"
--   
--   instance ToParam (QueryParam "capital" Bool) where
--     toParam _ =
--       DocQueryParam "capital"
--                     ["true", "false"]
--                     "Get the greeting message in uppercase (true) or not (false). Default is false."
--   
--   instance ToCapture (Capture "name" Text) where
--     toCapture _ = DocCapture "name" "name of the person to greet"
--   
--   instance ToCapture (Capture "greetid" Text) where
--     toCapture _ = DocCapture "greetid" "identifier of the greet msg to remove"
--   
--   -- API specification
--   type TestApi =
--          "hello" :&gt; Capture "name" Text :&gt; QueryParam "capital" Bool :&gt; Get Greet
--     :&lt;|&gt; "greet" :&gt; RQBody Greet :&gt; Post Greet
--     :&lt;|&gt; "delete" :&gt; Capture "greetid" Text :&gt; Delete
--   
--   testApi :: Proxy TestApi
--   testApi = Proxy
--   
--   -- Generate the Documentation's ADT
--   greetDocs :: API
--   greetDocs = docs testApi
--   
--   main :: IO ()
--   main = putStrLn $ markdown greetDocs
--   </pre>
module Servant.Docs

-- | The class that abstracts away the impact of API combinators on
--   documentation generation.
class HasDocs layout
docsFor :: HasDocs layout => Proxy layout -> (Endpoint, Action) -> API

-- | Generate the docs for a given API that implements <a>HasDocs</a>.
docs :: HasDocs layout => Proxy layout -> API

-- | Generate documentation in Markdown format for the given <a>API</a>.
markdown :: API -> String

-- | The class that lets us display a sample JSON input or output when
--   generating documentation for endpoints that either:
--   
--   <ul>
--   <li>expect a request body, or</li>
--   <li>return a non empty response body</li>
--   </ul>
--   
--   Example of an instance:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Data.Aeson
--   import Data.Text
--   import GHC.Generics
--   
--   data Greet = Greet { _msg :: Text }
--     deriving (Generic, Show)
--   
--   instance FromJSON Greet
--   instance ToJSON Greet
--   
--   instance ToSample Greet where
--     toSample = Just g
--   
--       where g = Greet "Hello, haskeller!"
--   </pre>
class ToJSON a => ToSample a
toSample :: ToSample a => Maybe a
sampleByteString :: ToSample a => Proxy a -> Maybe ByteString

-- | The class that helps us automatically get documentation for GET
--   parameters.
--   
--   Example of an instance:
--   
--   <pre>
--   instance ToParam (QueryParam "capital" Bool) where
--     toParam _ =
--       DocQueryParam "capital"
--                     ["true", "false"]
--                     "Get the greeting message in uppercase (true) or not (false). Default is false."
--   </pre>
class ToParam t
toParam :: ToParam t => Proxy t -> DocQueryParam

-- | The class that helps us automatically get documentation for URL
--   captures.
--   
--   Example of an instance:
--   
--   <pre>
--   instance ToCapture (Capture "name" Text) where
--     toCapture _ = DocCapture "name" "name of the person to greet"
--   </pre>
class ToCapture c
toCapture :: ToCapture c => Proxy c -> DocCapture

-- | Supported HTTP request methods
data Method

-- | the DELETE method
DocDELETE :: Method

-- | the GET method
DocGET :: Method

-- | the POST method
DocPOST :: Method

-- | the PUT method
DocPUT :: Method

-- | An <a>Endpoint</a> type that holds the <a>path</a> and the
--   <a>method</a>.
--   
--   Gets used as the key in the <a>API</a> hashmap. Modify
--   <a>defEndpoint</a> or any <a>Endpoint</a> value you want using the
--   <a>path</a> and <a>method</a> lenses to tweak.
--   
--   <pre>
--   λ&gt; <a>defEndpoint</a>
--   GET /
--   λ&gt; <a>defEndpoint</a> &amp; <a>path</a> <a>&lt;&gt;~</a> "foo"
--   GET /foo
--   λ&gt; <a>defEndpoint</a> &amp; <a>path</a> <a>&lt;&gt;~</a> "foo" &amp; <a>method</a> <a>.~</a> <a>DocPOST</a>
--   POST /foo
--   </pre>
data Endpoint
path :: Lens' Endpoint String
method :: Lens' Endpoint Method

-- | An <a>Endpoint</a> whose path is `"/"` and whose method is
--   <a>DocGET</a>
--   
--   Here's how you can modify it:
--   
--   <pre>
--   λ&gt; <a>defEndpoint</a>
--   GET /
--   λ&gt; <a>defEndpoint</a> &amp; <a>path</a> <a>&lt;&gt;~</a> "foo"
--   GET /foo
--   λ&gt; <a>defEndpoint</a> &amp; <a>path</a> <a>&lt;&gt;~</a> "foo" &amp; <a>method</a> <a>.~</a> <a>DocPOST</a>
--   POST /foo
--   </pre>
defEndpoint :: Endpoint

-- | Our API type, a good old hashmap from <a>Endpoint</a> to <a>Action</a>
type API = HashMap Endpoint Action

-- | An empty <a>API</a>
emptyAPI :: API

-- | A type to represent captures. Holds the name of the capture and a
--   description.
--   
--   Write a <a>ToCapture</a> instance for your captured types.
data DocCapture
DocCapture :: String -> String -> DocCapture
_capSymbol :: DocCapture -> String
_capDesc :: DocCapture -> String
capSymbol :: Lens' DocCapture String
capDesc :: Lens' DocCapture String

-- | A type to represent a <i>GET</i> parameter from the Query String.
--   Holds its name, the possible values (leave empty if there isn't a
--   finite number of them), and a description of how it influences the
--   output or behavior.
--   
--   Write a <a>ToParam</a> instance for your GET parameter types
data DocQueryParam
DocQueryParam :: String -> [String] -> String -> ParamKind -> DocQueryParam
_paramName :: DocQueryParam -> String
_paramValues :: DocQueryParam -> [String]
_paramDesc :: DocQueryParam -> String
_paramKind :: DocQueryParam -> ParamKind

-- | Type of GET parameter:
--   
--   <ul>
--   <li>Normal corresponds to <tt>QueryParam</tt>, i.e your usual GET
--   parameter</li>
--   <li>List corresponds to <tt>QueryParams</tt>, i.e GET parameters with
--   multiple values</li>
--   <li>Flag corresponds to <tt>QueryFlag</tt>, i.e a value-less GET
--   parameter</li>
--   </ul>
data ParamKind
Normal :: ParamKind
List :: ParamKind
Flag :: ParamKind
paramName :: Lens' DocQueryParam String
paramValues :: Lens' DocQueryParam [String]
paramDesc :: Lens' DocQueryParam String
paramKind :: Lens' DocQueryParam ParamKind

-- | A type to represent an HTTP response. Has an <a>Int</a> status and a
--   'Maybe ByteString' response body. Tweak <a>defResponse</a> using the
--   <a>respStatus</a> and <a>respBody</a> lenses if you want.
--   
--   If you want to respond with a non-empty response body, you'll most
--   likely want to write a <a>ToSample</a> instance for the type that'll
--   be represented as some JSON in the response.
--   
--   Can be tweaked with two lenses.
--   
--   <pre>
--   λ&gt; defResponse
--   Response {_respStatus = 200, _respBody = Nothing}
--   λ&gt; defResponse &amp; respStatus .~ 204 &amp; respBody .~ Just "[]"
--   Response {_respStatus = 204, _respBody = Just "[]"}
--   </pre>
data Response
respStatus :: Lens' Response Int
respBody :: Lens' Response (Maybe ByteString)

-- | Default response: status code 200, no response body.
--   
--   Can be tweaked with two lenses.
--   
--   <pre>
--   λ&gt; defResponse
--   Response {_respStatus = 200, _respBody = Nothing}
--   λ&gt; defResponse &amp; respStatus .~ 204 &amp; respBody .~ Just "[]"
--   Response {_respStatus = 204, _respBody = Just "[]"}
--   </pre>
defResponse :: Response

-- | A datatype that represents everything that can happen at an endpoint,
--   with its lenses:
--   
--   <ul>
--   <li>List of captures (<a>captures</a>)</li>
--   <li>List of GET parameters (<a>params</a>)</li>
--   <li>What the request body should look like, if any is requested
--   (<a>rqbody</a>)</li>
--   <li>What the response should be if everything goes well
--   (<a>response</a>)</li>
--   </ul>
--   
--   You can tweak an <a>Action</a> (like the default <a>defAction</a>)
--   with these lenses to transform an action and add some information to
--   it.
data Action
captures :: Lens' Action [DocCapture]
params :: Lens' Action [DocQueryParam]
rqbody :: Lens' Action (Maybe ByteString)
response :: Lens' Action Response
defAction :: Action

-- | Create an API that's comprised of a single endpoint. <a>API</a> is a
--   <a>Monoid</a>, so combine multiple endpoints with <a>mappend</a> or
--   <a>&lt;&gt;</a>.
single :: Endpoint -> Action -> API
instance ToSample ()
instance Eq Method
instance Generic Method
instance Eq Endpoint
instance Generic Endpoint
instance Eq DocCapture
instance Show DocCapture
instance Eq ParamKind
instance Show ParamKind
instance Eq DocQueryParam
instance Show DocQueryParam
instance Eq Response
instance Show Response
instance Eq Action
instance Show Action
instance Datatype D1Method
instance Constructor C1_0Method
instance Constructor C1_1Method
instance Constructor C1_2Method
instance Constructor C1_3Method
instance Datatype D1Endpoint
instance Constructor C1_0Endpoint
instance Selector S1_0_0Endpoint
instance Selector S1_0_1Endpoint
instance Hashable Endpoint
instance Show Endpoint
instance Hashable Method
instance Show Method


-- | This module provides <a>client</a> which can automatically generate
--   querying functions for each endpoint just from the type representing
--   your API.
module Servant.Client

-- | <a>client</a> allows you to produce operations to query an API from a
--   client.
--   
--   <pre>
--   type MyApi = "books" :&gt; Get [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody Book :&gt; Post Book -- POST /books
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   getAllBooks :: BaseUrl -&gt; EitherT String IO [Book]
--   postNewBook :: Book -&gt; BaseUrl -&gt; EitherT String IO Book
--   (getAllBooks :&lt;|&gt; postNewBook) = client myApi
--   </pre>
client :: HasClient layout => Proxy layout -> Client layout

-- | This class lets us define how each API combinator influences the
--   creation of an HTTP request. Use <a>client</a> directly, this class
--   implements the client-side behavior of each combinator but you don't
--   have to worry about it.
class HasClient layout where type family Client layout :: *
clientWithRoute :: HasClient layout => Proxy layout -> Req -> Client layout


-- | This module lets you implement <a>Server</a>s for defined APIs. You'll
--   most likely just need <a>serve</a>.
module Servant.Server

-- | <a>serve</a> allows you to implement an API and produce a wai
--   <a>Application</a>.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; Get [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody Book :&gt; Post Book -- POST /books
--   
--   server :: Server MyApi
--   server = listAllBooks :&lt;|&gt; postBook
--     where listAllBooks = ...
--           postBook book = ...
--   
--   app :: Application
--   app = serve myApi server
--   
--   main :: IO ()
--   main = Network.Wai.Handler.Warp.run 8080 app
--   </pre>
serve :: HasServer layout => Proxy layout -> Server layout -> Application
toApplication :: RoutingApplication -> Application
data RouteMismatch

-- | the usual "not found" error
NotFound :: RouteMismatch

-- | a more informative "you just got the HTTP method wrong" error
WrongMethod :: RouteMismatch

-- | an even more informative "your json request body wasn't valid" error
InvalidBody :: RouteMismatch

-- | <pre>
--   &gt; mempty = NotFound
--   &gt;
--   &gt; NotFound    <a>mappend</a>           x = x
--   &gt; WrongMethod <a>mappend</a> InvalidBody = InvalidBody
--   &gt; WrongMethod <a>mappend</a>           _ = WrongMethod
--   &gt; InvalidBody <a>mappend</a>           _ = InvalidBody
--   </pre>

-- | A wrapper around <tt><a>Either</a> <a>RouteMismatch</a> a</tt>.
newtype RouteResult a
RR :: Either RouteMismatch a -> RouteResult a
routeResult :: RouteResult a -> Either RouteMismatch a
failWith :: RouteMismatch -> RouteResult a
succeedWith :: a -> RouteResult a
isMismatch :: RouteResult a -> Bool

-- | If we get a <a>Right</a>, it has precedence over everything else.
--   
--   This in particular means that if we could get several <a>Right</a>s,
--   only the first we encounter would be taken into account.
type RoutingApplication = Request -> (RouteResult Response -> IO ResponseReceived) -> IO ResponseReceived
class HasServer layout where type family Server layout :: *
route :: HasServer layout => Proxy layout -> Server layout -> RoutingApplication
instance Eq RouteMismatch
instance Show RouteMismatch
instance Eq a => Eq (RouteResult a)
instance Show a => Show (RouteResult a)
instance Monoid (RouteResult a)
instance Monoid RouteMismatch

module Servant.API.Sub

-- | The contained API (second argument) can be found under <tt>("/" ++
--   path)</tt> (path being the first argument).
--   
--   Example:
--   
--   <pre>
--   -- GET /hello/world
--   -- returning a JSON encoded World value
--   type MyApi = "hello" :&gt; "world" :&gt; Get World
--   </pre>
data (:>) (path :: k) a
(:>) :: Proxy path -> a -> (:>) a

-- | Make sure the incoming request starts with <tt>"/path"</tt>, strip it
--   and pass the rest of the request path to <tt>sublayout</tt>.

-- | Make the querying function append <tt>path</tt> to the request path.
instance (KnownSymbol path, HasDocs sublayout) => HasDocs (path :> sublayout)
instance (KnownSymbol path, HasClient sublayout) => HasClient (path :> sublayout)
instance (KnownSymbol path, HasServer sublayout) => HasServer (path :> sublayout)

module Servant.API.Alternative

-- | Union of two APIs, first takes precedence in case of overlap.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; Get [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody Book :&gt; Post Book -- POST /books
--   </pre>
data (:<|>) a b
(:<|>) :: a -> b -> (:<|>) a b

-- | A server for <tt>a <a>:&lt;|&gt;</a> b</tt> first tries to match the
--   request again the route represented by <tt>a</tt> and if it fails
--   tries <tt>b</tt>. You must provide a request handler for each route.
--   
--   <pre>
--   type MyApi = "books" :&gt; Get [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody Book :&gt; Post Book -- POST /books
--   
--   server :: Server MyApi
--   server = listAllBooks :&lt;|&gt; postBook
--     where listAllBooks = ...
--           postBook book = ...
--   </pre>

-- | A client querying function for <tt>a <a>:&lt;|&gt;</a> b</tt> will
--   actually hand you one function for querying <tt>a</tt> and another one
--   for querying <tt>b</tt>, stitching them together with
--   <a>:&lt;|&gt;</a>, which really is just like a pair.
--   
--   <pre>
--   type MyApi = "books" :&gt; Get [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody Book :&gt; Post Book -- POST /books
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   getAllBooks :: BaseUrl -&gt; EitherT String IO [Book]
--   postNewBook :: Book -&gt; BaseUrl -&gt; EitherT String IO Book
--   (getAllBooks :&lt;|&gt; postNewBook) = client myApi
--   </pre>

-- | The generated docs for <tt>a <a>:&lt;|&gt;</a> b</tt> just appends the
--   docs for <tt>a</tt> with the docs for <tt>b</tt>.
instance (HasDocs layout1, HasDocs layout2) => HasDocs (layout1 :<|> layout2)
instance (HasClient a, HasClient b) => HasClient (a :<|> b)
instance (HasServer a, HasServer b) => HasServer (a :<|> b)

module Servant.API.Capture

-- | Capture a value from the request path under a certain type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--              -- GET /books/:isbn
--   type MyApi = "books" :&gt; Capture "isbn" Text :&gt; Get Book
--   </pre>
data Capture sym a
instance (KnownSymbol sym, ToCapture (Capture sym a), HasDocs sublayout) => HasDocs (Capture sym a :> sublayout)
instance (KnownSymbol capture, ToText a, HasClient sublayout) => HasClient (Capture capture a :> sublayout)
instance (KnownSymbol capture, FromText a, HasServer sublayout) => HasServer (Capture capture a :> sublayout)

module Servant.API.QueryParam

-- | Lookup the value associated to the <tt>sym</tt> query string parameter
--   and try to extract it as a value of type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   -- /books?author=&lt;author name&gt;
--   type MyApi = "books" :&gt; QueryParam "author" Text :&gt; Get [Book]
--   </pre>
data QueryParam sym a

-- | If you use <tt><a>QueryParam</a> "author" Text</tt> in one of the
--   endpoints for your API, this automatically requires your server-side
--   handler to be a function that takes an argument of type
--   <tt><a>Maybe</a> <tt>Text</tt></tt>.
--   
--   This lets servant worry about looking it up in the query string and
--   turning it into a value of the type you specify, enclosed in
--   <a>Maybe</a>, because it may not be there and servant would then hand
--   you <a>Nothing</a>.
--   
--   You can control how it'll be converted from <tt>Text</tt> to your type
--   by simply providing an instance of <a>FromText</a> for your type.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; QueryParam "author" Text :&gt; Get [Book]
--   
--   server :: Server MyApi
--   server = getBooksBy
--     where getBooksBy :: Maybe Text -&gt; EitherT (Int, String) IO [Book]
--           getBooksBy Nothing       = ...return all books...
--           getBooksBy (Just author) = ...return books by the given author...
--   </pre>

-- | If you use a <a>QueryParam</a> in one of your endpoints in your API,
--   the corresponding querying function will automatically take an
--   additional argument of the type specified by your <a>QueryParam</a>,
--   enclosed in Maybe.
--   
--   If you give Nothing, nothing will be added to the query string.
--   
--   If you give a non-<a>Nothing</a> value, this function will take care
--   of inserting a textual representation of this value in the query
--   string.
--   
--   You can control how values for your type are turned into text by
--   specifying a <a>ToText</a> instance for your type.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; QueryParam "author" Text :&gt; Get [Book]
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   getBooksBy :: Maybe Text -&gt; BaseUrl -&gt; EitherT String IO [Book]
--   getBooksBy = client myApi
--   -- then you can just use "getBooksBy" to query that endpoint.
--   -- 'getBooksBy Nothing' for all books
--   -- 'getBooksBy (Just "Isaac Asimov")' to get all books by Isaac Asimov
--   </pre>

-- | Lookup the values associated to the <tt>sym</tt> query string
--   parameter and try to extract it as a value of type <tt>[a]</tt>. This
--   is typically meant to support query string parameters of the form
--   <tt>param[]=val1&amp;param[]=val2</tt> and so on. Note that servant
--   doesn't actually require the <tt>[]</tt>s and will fetch the values
--   just fine with <tt>param=val1&amp;param=val2</tt>, too.
--   
--   Example:
--   
--   <pre>
--   -- /books?authors[]=&lt;author1&gt;&amp;authors[]=&lt;author2&gt;&amp;...
--   type MyApi = "books" :&gt; QueryParams "authors" Text :&gt; Get [Book]
--   </pre>
data QueryParams sym a

-- | If you use <tt><a>QueryParams</a> "authors" Text</tt> in one of the
--   endpoints for your API, this automatically requires your server-side
--   handler to be a function that takes an argument of type
--   <tt>[<tt>Text</tt>]</tt>.
--   
--   This lets servant worry about looking up 0 or more values in the query
--   string associated to <tt>authors</tt> and turning each of them into a
--   value of the type you specify.
--   
--   You can control how the individual values are converted from
--   <tt>Text</tt> to your type by simply providing an instance of
--   <a>FromText</a> for your type.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; QueryParams "authors" Text :&gt; Get [Book]
--   
--   server :: Server MyApi
--   server = getBooksBy
--     where getBooksBy :: [Text] -&gt; EitherT (Int, String) IO [Book]
--           getBooksBy authors = ...return all books by these authors...
--   </pre>

-- | If you use a <a>QueryParams</a> in one of your endpoints in your API,
--   the corresponding querying function will automatically take an
--   additional argument, a list of values of the type specified by your
--   <a>QueryParams</a>.
--   
--   If you give an empty list, nothing will be added to the query string.
--   
--   Otherwise, this function will take care of inserting a textual
--   representation of your values in the query string, under the same
--   query string parameter name.
--   
--   You can control how values for your type are turned into text by
--   specifying a <a>ToText</a> instance for your type.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; QueryParams "authors" Text :&gt; Get [Book]
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   getBooksBy :: [Text] -&gt; BaseUrl -&gt; EitherT String IO [Book]
--   getBooksBy = client myApi
--   -- then you can just use "getBooksBy" to query that endpoint.
--   -- 'getBooksBy []' for all books
--   -- 'getBooksBy ["Isaac Asimov", "Robert A. Heinlein"]'
--   --   to get all books by Asimov and Heinlein
--   </pre>

-- | Lookup a potentially value-less query string parameter with boolean
--   semantics. If the param <tt>sym</tt> is there without any value, or if
--   it's there with value "true" or "1", it's interpreted as <a>True</a>.
--   Otherwise, it's interpreted as <a>False</a>.
--   
--   Example:
--   
--   <pre>
--   -- /books?published
--   type MyApi = "books" :&gt; QueryFlag "published" :&gt; Get [Book]
--   </pre>
data QueryFlag sym

-- | If you use <tt><a>QueryFlag</a> "published"</tt> in one of the
--   endpoints for your API, this automatically requires your server-side
--   handler to be a function that takes an argument of type <a>Bool</a>.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; QueryFlag "published" :&gt; Get [Book]
--   
--   server :: Server MyApi
--   server = getBooks
--     where getBooks :: Bool -&gt; EitherT (Int, String) IO [Book]
--           getBooks onlyPublished = ...return all books, or only the ones that are already published, depending on the argument...
--   </pre>

-- | If you use a <a>QueryFlag</a> in one of your endpoints in your API,
--   the corresponding querying function will automatically take an
--   additional <a>Bool</a> argument.
--   
--   If you give <a>False</a>, nothing will be added to the query string.
--   
--   Otherwise, this function will insert a value-less query string
--   parameter under the name associated to your <a>QueryFlag</a>.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; QueryFlag "published" :&gt; Get [Book]
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   getBooks :: Bool -&gt; BaseUrl -&gt; EitherT String IO [Book]
--   getBooks = client myApi
--   -- then you can just use "getBooks" to query that endpoint.
--   -- 'getBooksBy False' for all books
--   -- 'getBooksBy True' to only get _already published_ books
--   </pre>
instance (KnownSymbol sym, ToParam (QueryFlag sym), HasDocs sublayout) => HasDocs (QueryFlag sym :> sublayout)
instance (KnownSymbol sym, HasClient sublayout) => HasClient (QueryFlag sym :> sublayout)
instance (KnownSymbol sym, HasServer sublayout) => HasServer (QueryFlag sym :> sublayout)
instance (KnownSymbol sym, ToParam (QueryParams sym a), HasDocs sublayout) => HasDocs (QueryParams sym a :> sublayout)
instance (KnownSymbol sym, ToText a, HasClient sublayout) => HasClient (QueryParams sym a :> sublayout)
instance (KnownSymbol sym, FromText a, HasServer sublayout) => HasServer (QueryParams sym a :> sublayout)
instance (KnownSymbol sym, ToParam (QueryParam sym a), HasDocs sublayout) => HasDocs (QueryParam sym a :> sublayout)
instance (KnownSymbol sym, ToText a, HasClient sublayout) => HasClient (QueryParam sym a :> sublayout)
instance (KnownSymbol sym, FromText a, HasServer sublayout) => HasServer (QueryParam sym a :> sublayout)

module Servant.API.ReqBody

-- | Extract the request body as a value of type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--              -- POST /books
--   type MyApi = "books" :&gt; ReqBody Book :&gt; Post Book
--   </pre>
data ReqBody a

-- | If you use <a>ReqBody</a> in one of the endpoints for your API, this
--   automatically requires your server-side handler to be a function that
--   takes an argument of the type specified by <a>ReqBody</a>. This lets
--   servant worry about extracting it from the request and turning it into
--   a value of the type you specify.
--   
--   All it asks is for a <a>FromJSON</a> instance.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; ReqBody Book :&gt; Post Book
--   
--   server :: Server MyApi
--   server = postBook
--     where postBook :: Book -&gt; EitherT (Int, String) IO Book
--           postBook book = ...insert into your db...
--   </pre>

-- | If you use a <a>ReqBody</a> in one of your endpoints in your API, the
--   corresponding querying function will automatically take an additional
--   argument of the type specified by your <a>ReqBody</a>. That function
--   will take care of encoding this argument as JSON and of using it as
--   the request body.
--   
--   All you need is for your type to have a <a>ToJSON</a> instance.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; ReqBody Book :&gt; Post Book
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   addBook :: Book -&gt; BaseUrl -&gt; EitherT String IO Book
--   addBook = client myApi
--   -- then you can just use "addBook" to query that endpoint
--   </pre>
instance (ToSample a, HasDocs sublayout) => HasDocs (ReqBody a :> sublayout)
instance (ToJSON a, HasClient sublayout) => HasClient (ReqBody a :> sublayout)
instance (FromJSON a, HasServer sublayout) => HasServer (ReqBody a :> sublayout)

module Servant.API.Get

-- | Endpoint for simple GET requests. Serves the result as JSON.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; Get [Book]
--   </pre>
data Get a

-- | When implementing the handler for a <a>Get</a> endpoint, just like for
--   <a>Delete</a>, <a>Post</a> and <a>Put</a>, the handler code runs in
--   the <tt>EitherT (Int, String) IO</tt> monad, where the <a>Int</a>
--   represents the status code and the <a>String</a> a message, returned
--   in case of failure. You can quite handily use <a>left</a> to quickly
--   fail if some conditions are not met.
--   
--   If successfully returning a value, we just require that its type has a
--   <a>ToJSON</a> instance and servant takes care of encoding it for you,
--   yielding status code 200 along the way.

-- | If you have a <a>Get</a> endpoint in your API, the client side
--   querying function that is created when calling <a>client</a> will just
--   require an argument that specifies the scheme, host and port to send
--   the request to.
instance Typeable Get
instance ToSample a => HasDocs (Get a)
instance FromJSON result => HasClient (Get result)
instance ToJSON result => HasServer (Get result)

module Servant.API.Post

-- | Endpoint for POST requests. The type variable represents the type of
--   the response body (not the request body, use <a>RQBody</a> for that).
--   
--   Example:
--   
--   <pre>
--              -- POST /books
--              -- with a JSON encoded Book as the request body
--              -- returning the just-created Book
--   type MyApi = "books" :&gt; ReqBody Book :&gt; Post Book
--   </pre>
data Post a

-- | When implementing the handler for a <a>Post</a> endpoint, just like
--   for <a>Delete</a>, <a>Get</a> and <a>Put</a>, the handler code runs in
--   the <tt>EitherT (Int, String) IO</tt> monad, where the <a>Int</a>
--   represents the status code and the <a>String</a> a message, returned
--   in case of failure. You can quite handily use <a>left</a> to quickly
--   fail if some conditions are not met.
--   
--   If successfully returning a value, we just require that its type has a
--   <a>ToJSON</a> instance and servant takes care of encoding it for you,
--   yielding status code 201 along the way.

-- | If you have a <a>Post</a> endpoint in your API, the client side
--   querying function that is created when calling <a>client</a> will just
--   require an argument that specifies the scheme, host and port to send
--   the request to.
instance Typeable Post
instance ToSample a => HasDocs (Post a)
instance FromJSON a => HasClient (Post a)
instance ToJSON a => HasServer (Post a)

module Servant.API.Delete

-- | Combinator for DELETE requests.
--   
--   Example:
--   
--   <pre>
--              -- DELETE /books/:isbn
--   type MyApi = "books" :&gt; Capture "isbn" Text :&gt; Delete
--   </pre>
data Delete

-- | If you have a <a>Delete</a> endpoint in your API, the handler for this
--   endpoint is meant to delete a resource.
--   
--   The code of the handler will, just like for <a>Get</a>, <a>Post</a>
--   and <a>Put</a>, run in <tt>EitherT (Int, String) IO ()</tt>. The
--   <a>Int</a> represents the status code and the <a>String</a> a message
--   to be returned. You can use <a>left</a> to painlessly error out if the
--   conditions for a successful deletion are not met.

-- | If you have a <a>Delete</a> endpoint in your API, the client side
--   querying function that is created when calling <a>client</a> will just
--   require an argument that specifies the scheme, host and port to send
--   the request to.
instance Typeable Delete
instance HasDocs Delete
instance HasClient Delete
instance HasServer Delete

module Servant.API.Put

-- | Endpoint for PUT requests, usually used to update a ressource. The
--   type <tt>a</tt> is the type of the response body that's returned.
--   
--   Example:
--   
--   <pre>
--   -- PUT /books/:isbn
--   -- with a Book as request body, returning the updated Book
--   type MyApi = "books" :&gt; Capture "isbn" Text :&gt; ReqBody Book :&gt; Put Book
--   </pre>
data Put a

-- | When implementing the handler for a <a>Put</a> endpoint, just like for
--   <a>Delete</a>, <a>Get</a> and <a>Post</a>, the handler code runs in
--   the <tt>EitherT (Int, String) IO</tt> monad, where the <a>Int</a>
--   represents the status code and the <a>String</a> a message, returned
--   in case of failure. You can quite handily use <a>left</a> to quickly
--   fail if some conditions are not met.
--   
--   If successfully returning a value, we just require that its type has a
--   <a>ToJSON</a> instance and servant takes care of encoding it for you,
--   yielding status code 200 along the way.

-- | If you have a <a>Put</a> endpoint in your API, the client side
--   querying function that is created when calling <a>client</a> will just
--   require an argument that specifies the scheme, host and port to send
--   the request to.
instance Typeable Put
instance ToSample a => HasDocs (Put a)
instance FromJSON a => HasClient (Put a)
instance ToJSON a => HasServer (Put a)

module Servant.Utils.ApiQuasiQuoting
class ExpSYM repr' repr | repr -> repr', repr' -> repr
lit :: ExpSYM repr' repr => String -> repr' -> repr
capture :: ExpSYM repr' repr => String -> String -> repr -> repr
reqBody :: ExpSYM repr' repr => String -> repr -> repr
queryParam :: ExpSYM repr' repr => String -> String -> repr -> repr
conj :: ExpSYM repr' repr => repr' -> repr -> repr
get :: ExpSYM repr' repr => String -> repr
post :: ExpSYM repr' repr => String -> repr
put :: ExpSYM repr' repr => String -> repr
delete :: ExpSYM repr' repr => String -> repr
(>:) :: Type -> Type -> Type
parseMethod :: ExpSYM repr' repr => Parser (String -> repr)
parseUrlSegment :: ExpSYM repr repr => Parser (repr -> repr)
parseUrl :: ExpSYM repr repr => Parser (repr -> repr)
data Typ
Val :: String -> Typ
ReqArgVal :: String -> String -> Typ
parseTyp :: Parser Typ
parseEntry :: ExpSYM repr repr => Parser repr
blockComment :: Parser ()
inlineComment :: Parser ()
eol :: Parser String
eols :: Parser ()
parseAll :: Parser Type
sitemap :: QuasiQuoter
instance ExpSYM Type Type

module Servant.Utils.Links

-- | The 'ValidLinkIn f s' constraint holds when <tt>s</tt> is an API that
--   contains <tt>f</tt>, and <tt>f</tt> is a link.
class ValidLinkIn f s
mkLink :: ValidLinkIn f s => f -> s -> Link
data Link
Link :: String -> Link
class VLinkHelper f
vlh :: VLinkHelper f => proxy f -> String
instance Show Link
instance VLinkHelper (Post x)
instance VLinkHelper (Get x)
instance (KnownSymbol s, VLinkHelper e) => VLinkHelper (s :> e)
instance (IsElem f s ~ 'True, IsLink f ~ 'True, VLinkHelper f) => ValidLinkIn f s

module Servant.API.Raw

-- | Endpoint for plugging in your own Wai <a>Application</a>s.
--   
--   The given <a>Application</a> will get the request as received by the
--   server, potentially with a modified (stripped) <a>pathInfo</a> if the
--   <a>Application</a> is being routed with <a>:&gt;</a>.
--   
--   In addition to just letting you plug in your existing WAI
--   <a>Application</a>s, this can also be used with <a>serveDirectory</a>
--   to serve static files stored in a particular directory on your
--   filesystem, or to serve your API's documentation with
--   <a>serveDocumentation</a>.
data Raw

-- | Just pass the request to the underlying application and serve its
--   response.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "images" :&gt; Raw
--   
--   server :: Server MyApi
--   server = serveDirectory "/var/www/images"
--   </pre>

-- | Pick a <a>Method</a> and specify where the server you want to query
--   is. You get back the status code and the response body as a
--   <a>ByteString</a>.
instance HasDocs Raw
instance HasClient Raw
instance HasServer Raw


-- | This module defines sever-side handlers that let you serve static
--   files.
--   
--   <ul>
--   <li><a>serveDirectory</a> lets you serve anything that lives under a
--   particular directory on your filesystem.</li>
--   <li><a>serveDocumentation</a> lets you serve the markdown-version of
--   the docs for your API.</li>
--   </ul>
module Servant.Utils.StaticFiles
serveDirectory :: FilePath -> Server Raw
serveDocumentation :: HasDocs api => Proxy api -> Server Raw

module Servant.API

module Servant

-- | A concrete, poly-kinded proxy type
data Proxy (t :: k) :: k -> *
Proxy :: Proxy
