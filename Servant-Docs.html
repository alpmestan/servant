<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Servant.Docs</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Servant-Docs.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Servant-Docs.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">servant-0.2</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>License</th><td>BSD-style</td></tr><tr><th>Maintainer</th><td>alpmestan@gmail.com</td></tr><tr><th>Stability</th><td>provisional</td></tr><tr><th>Portability</th><td>TH, TypeFamilies, DeriveGeneric</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Servant.Docs</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1"><code>HasDocs</code> class and key functions</a></li><li><a href="#g:2">Classes you need to implement for your types</a></li><li><a href="#g:3">ADTs to represent an <code>API</code></a></li><li><a href="#g:4">Useful modules when defining your own instances</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module lets you get API docs for free. It lets generate
 an <code><a href="Servant-Docs.html#t:API">API</a></code> from the type that represents your API using <code><a href="Servant-Docs.html#v:docs">docs</a></code>:</p><pre>docs :: <code><a href="Servant-Docs.html#t:HasDocs">HasDocs</a></code> api =&gt; <code><a href="Servant.html#t:Proxy">Proxy</a></code> api -&gt; <code><a href="Servant-Docs.html#t:API">API</a></code></pre><p>You can then call <code><a href="Servant-Docs.html#v:markdown">markdown</a></code> on it:</p><pre>printMarkdown :: <code><a href="Servant-Docs.html#t:API">API</a></code> -&gt; String</pre><p>or define a custom pretty printer:</p><pre>yourPrettyDocs :: <code><a href="Servant-Docs.html#t:API">API</a></code> -&gt; String -- or blaze-html's HTML, or ...</pre><p>The only thing you'll need to do will be to implement some classes
 for your captures, get parameters and request or response bodies.</p><p>Here's a little (but complete) example that you can run to see the
 markdown pretty printer in action:</p><pre>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Proxy
import Data.Text
import Servant
import Servant.Docs

-- our type for a Greeting message
data Greet = Greet { _msg :: Text }
  deriving (Generic, Show)

-- we get our JSON serialization for free
instance FromJSON Greet
instance ToJSON Greet

-- we provide a sample value for the 'Greet' type
instance ToSample Greet where
  toSample Proxy = Just (encode g)

    where g = Greet &quot;Hello, haskeller!&quot;

instance ToParam (QueryParam &quot;capital&quot; Bool) where
  toParam _ =
    DocQueryParam &quot;capital&quot;
                  [&quot;true&quot;, &quot;false&quot;]
                  &quot;Get the greeting message in uppercase (true) or not (false). Default is false.&quot;

instance ToCapture (Capture &quot;name&quot; Text) where
  toCapture _ = DocCapture &quot;name&quot; &quot;name of the person to greet&quot;

instance ToCapture (Capture &quot;greetid&quot; Text) where
  toCapture _ = DocCapture &quot;greetid&quot; &quot;identifier of the greet msg to remove&quot;

-- API specification
type TestApi =
       &quot;hello&quot; :&gt; Capture &quot;name&quot; Text :&gt; QueryParam &quot;capital&quot; Bool :&gt; Get Greet
  :&lt;|&gt; &quot;greet&quot; :&gt; RQBody Greet :&gt; Post Greet
  :&lt;|&gt; &quot;delete&quot; :&gt; Capture &quot;greetid&quot; Text :&gt; Delete

testApi :: Proxy TestApi
testApi = Proxy

-- Generate the Documentation's ADT
greetDocs :: API
greetDocs = docs testApi

main :: IO ()
main = putStrLn $ markdown greetDocs</pre></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> <a href="#t:HasDocs">HasDocs</a> layout <span class="keyword">where</span><ul class="subs"><li><a href="#v:docsFor">docsFor</a> :: <a href="Servant.html#t:Proxy">Proxy</a> layout -&gt; (<a href="Servant-Docs.html#t:Endpoint">Endpoint</a>, <a href="Servant-Docs.html#t:Action">Action</a>) -&gt; <a href="Servant-Docs.html#t:API">API</a></li></ul></li><li class="src short"><a href="#v:docs">docs</a> :: <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> layout =&gt; <a href="Servant.html#t:Proxy">Proxy</a> layout -&gt; <a href="Servant-Docs.html#t:API">API</a></li><li class="src short"><a href="#v:markdown">markdown</a> :: <a href="Servant-Docs.html#t:API">API</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></li><li class="src short"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-Types.html#t:ToJSON">ToJSON</a> a =&gt; <a href="#t:ToSample">ToSample</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:toSample">toSample</a> :: <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> a</li></ul></li><li class="src short"><a href="#v:sampleByteString">sampleByteString</a> :: <span class="keyword">forall</span> a. <a href="Servant-Docs.html#t:ToSample">ToSample</a> a =&gt; <a href="Servant.html#t:Proxy">Proxy</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></li><li class="src short"><span class="keyword">class</span> <a href="#t:ToParam">ToParam</a> t <span class="keyword">where</span><ul class="subs"><li><a href="#v:toParam">toParam</a> :: <a href="Servant.html#t:Proxy">Proxy</a> t -&gt; <a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a></li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:ToCapture">ToCapture</a> c <span class="keyword">where</span><ul class="subs"><li><a href="#v:toCapture">toCapture</a> :: <a href="Servant.html#t:Proxy">Proxy</a> c -&gt; <a href="Servant-Docs.html#t:DocCapture">DocCapture</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Method">Method</a><ul class="subs"><li>= <a href="#v:DocDELETE">DocDELETE</a></li><li>| <a href="#v:DocGET">DocGET</a></li><li>| <a href="#v:DocPOST">DocPOST</a></li><li>| <a href="#v:DocPUT">DocPUT</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Endpoint">Endpoint</a></li><li class="src short"><a href="#v:path">path</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Endpoint">Endpoint</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:method">method</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Endpoint">Endpoint</a> <a href="Servant-Docs.html#t:Method">Method</a></li><li class="src short"><a href="#v:defEndpoint">defEndpoint</a> :: <a href="Servant-Docs.html#t:Endpoint">Endpoint</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:API">API</a> = <a href="https://hackage.haskell.org/package/unordered-containers-0.2.5.1/docs/Data-HashMap-Strict.html#t:HashMap">HashMap</a> <a href="Servant-Docs.html#t:Endpoint">Endpoint</a> <a href="Servant-Docs.html#t:Action">Action</a></li><li class="src short"><a href="#v:emptyAPI">emptyAPI</a> :: <a href="Servant-Docs.html#t:API">API</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:DocCapture">DocCapture</a> = <a href="#v:DocCapture">DocCapture</a> {<ul class="subs"><li><a href="#v:_capSymbol">_capSymbol</a> :: <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></li><li><a href="#v:_capDesc">_capDesc</a> :: <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></li></ul>}</li><li class="src short"><a href="#v:capSymbol">capSymbol</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:DocCapture">DocCapture</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:capDesc">capDesc</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:DocCapture">DocCapture</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:DocQueryParam">DocQueryParam</a> = <a href="#v:DocQueryParam">DocQueryParam</a> {<ul class="subs"><li><a href="#v:_paramName">_paramName</a> :: <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></li><li><a href="#v:_paramValues">_paramValues</a> :: [<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a>]</li><li><a href="#v:_paramDesc">_paramDesc</a> :: <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></li><li><a href="#v:_paramKind">_paramKind</a> :: <a href="Servant-Docs.html#t:ParamKind">ParamKind</a></li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:ParamKind">ParamKind</a><ul class="subs"><li>= <a href="#v:Normal">Normal</a></li><li>| <a href="#v:List">List</a></li><li>| <a href="#v:Flag">Flag</a></li></ul></li><li class="src short"><a href="#v:paramName">paramName</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:paramValues">paramValues</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a> [<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a>]</li><li class="src short"><a href="#v:paramDesc">paramDesc</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:paramKind">paramKind</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a> <a href="Servant-Docs.html#t:ParamKind">ParamKind</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Response">Response</a></li><li class="src short"><a href="#v:respStatus">respStatus</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Response">Response</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:respBody">respBody</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Response">Response</a> (<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:defResponse">defResponse</a> :: <a href="Servant-Docs.html#t:Response">Response</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Action">Action</a></li><li class="src short"><a href="#v:captures">captures</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Action">Action</a> [<a href="Servant-Docs.html#t:DocCapture">DocCapture</a>]</li><li class="src short"><a href="#v:params">params</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Action">Action</a> [<a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a>]</li><li class="src short"><a href="#v:rqbody">rqbody</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Action">Action</a> (<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:response">response</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Action">Action</a> <a href="Servant-Docs.html#t:Response">Response</a></li><li class="src short"><a href="#v:defAction">defAction</a> :: <a href="Servant-Docs.html#t:Action">Action</a></li><li class="src short"><a href="#v:single">single</a> :: <a href="Servant-Docs.html#t:Endpoint">Endpoint</a> -&gt; <a href="Servant-Docs.html#t:Action">Action</a> -&gt; <a href="Servant-Docs.html#t:API">API</a></li><li class="src short">module <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens.html">Control.Lens</a></li><li class="src short">module <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Monoid.html">Data.Monoid</a></li></ul></div><div id="interface"><h1 id="g:1"><code><a href="Servant-Docs.html#t:HasDocs">HasDocs</a></code> class and key functions</h1><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HasDocs" class="def">HasDocs</a> layout <span class="keyword">where</span> <a href="src/Servant-Docs.html#HasDocs" class="link">Source</a></p><div class="doc"><p>The class that abstracts away the impact of API combinators
   on documentation generation.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:docsFor" class="def">docsFor</a> :: <a href="Servant.html#t:Proxy">Proxy</a> layout -&gt; (<a href="Servant-Docs.html#t:Endpoint">Endpoint</a>, <a href="Servant-Docs.html#t:Action">Action</a>) -&gt; <a href="Servant-Docs.html#t:API">API</a> <a href="src/Servant-Docs.html#docsFor" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:HasDocs" class="caption collapser" onclick="toggleSection('i:HasDocs')">Instances</p><div id="section.i:HasDocs" class="show"><table><tr><td class="src"><a href="Servant-Docs.html#t:HasDocs">HasDocs</a> <a href="Servant-API-Delete.html#t:Delete">Delete</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Servant-Docs.html#t:HasDocs">HasDocs</a> <a href="Servant-API-Raw.html#t:Raw">Raw</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Servant-Docs.html#t:ToSample">ToSample</a> a =&gt; <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> (<a href="Servant-API-Get.html#t:Get">Get</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Servant-Docs.html#t:ToSample">ToSample</a> a =&gt; <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> (<a href="Servant-API-Post.html#t:Post">Post</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Servant-Docs.html#t:ToSample">ToSample</a> a =&gt; <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> (<a href="Servant-API-Put.html#t:Put">Put</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Servant-Docs.html#t:HasDocs">HasDocs</a> layout1, <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> layout2) =&gt; <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> (<a href="Servant-API-Alternative.html#t::-60--124--62-">(:&lt;|&gt;)</a> layout1 layout2)</td><td class="doc"><p>The generated docs for <code>a <code><a href="Servant-API-Alternative.html#t::-60--124--62-">:&lt;|&gt;</a></code> b</code> just append the docs
   for <code>a</code> with the docs for <code>b</code>.</p></td></tr><tr><td class="src">(<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:KnownSymbol">KnownSymbol</a> sym, <a href="Servant-Docs.html#t:ToCapture">ToCapture</a> (<a href="Servant-API-Capture.html#t:Capture">Capture</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:Symbol">Symbol</a> k sym a), <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> sublayout) =&gt; <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> (<a href="Servant-API-Sub.html#t::-62-">(:&gt;)</a> * (<a href="Servant-API-Capture.html#t:Capture">Capture</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:Symbol">Symbol</a> k sym a) sublayout)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:KnownSymbol">KnownSymbol</a> sym, <a href="Servant-Docs.html#t:ToParam">ToParam</a> (<a href="Servant-API-QueryParam.html#t:QueryFlag">QueryFlag</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:Symbol">Symbol</a> sym), <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> sublayout) =&gt; <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> (<a href="Servant-API-Sub.html#t::-62-">(:&gt;)</a> * (<a href="Servant-API-QueryParam.html#t:QueryFlag">QueryFlag</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:Symbol">Symbol</a> sym) sublayout)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:KnownSymbol">KnownSymbol</a> sym, <a href="Servant-Docs.html#t:ToParam">ToParam</a> (<a href="Servant-API-QueryParam.html#t:QueryParams">QueryParams</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:Symbol">Symbol</a> k sym a), <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> sublayout) =&gt; <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> (<a href="Servant-API-Sub.html#t::-62-">(:&gt;)</a> * (<a href="Servant-API-QueryParam.html#t:QueryParams">QueryParams</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:Symbol">Symbol</a> k sym a) sublayout)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:KnownSymbol">KnownSymbol</a> sym, <a href="Servant-Docs.html#t:ToParam">ToParam</a> (<a href="Servant-API-QueryParam.html#t:QueryParam">QueryParam</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:Symbol">Symbol</a> k sym a), <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> sublayout) =&gt; <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> (<a href="Servant-API-Sub.html#t::-62-">(:&gt;)</a> * (<a href="Servant-API-QueryParam.html#t:QueryParam">QueryParam</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:Symbol">Symbol</a> k sym a) sublayout)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Servant-Docs.html#t:ToSample">ToSample</a> a, <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> sublayout) =&gt; <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> (<a href="Servant-API-Sub.html#t::-62-">(:&gt;)</a> * (<a href="Servant-API-ReqBody.html#t:ReqBody">ReqBody</a> * a) sublayout)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:KnownSymbol">KnownSymbol</a> path, <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> sublayout) =&gt; <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> (<a href="Servant-API-Sub.html#t::-62-">(:&gt;)</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:Symbol">Symbol</a> path sublayout)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:docs" class="def">docs</a> :: <a href="Servant-Docs.html#t:HasDocs">HasDocs</a> layout =&gt; <a href="Servant.html#t:Proxy">Proxy</a> layout -&gt; <a href="Servant-Docs.html#t:API">API</a> <a href="src/Servant-Docs.html#docs" class="link">Source</a></p><div class="doc"><p>Generate the docs for a given API that implements <code><a href="Servant-Docs.html#t:HasDocs">HasDocs</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:markdown" class="def">markdown</a> :: <a href="Servant-Docs.html#t:API">API</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a> <a href="src/Servant-Docs.html#markdown" class="link">Source</a></p><div class="doc"><p>Generate documentation in Markdown format for
   the given <code><a href="Servant-Docs.html#t:API">API</a></code>.</p></div></div><h1 id="g:2">Classes you need to implement for your types</h1><div class="top"><p class="src"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-Types.html#t:ToJSON">ToJSON</a> a =&gt; <a name="t:ToSample" class="def">ToSample</a> a <span class="keyword">where</span> <a href="src/Servant-Docs.html#ToSample" class="link">Source</a></p><div class="doc"><p>The class that lets us display a sample JSON input or output
   when generating documentation for endpoints that either:</p><ul><li>expect a request body, or</li><li>return a non empty response body</li></ul><p>Example of an instance:</p><pre>{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Aeson
import Data.Text
import GHC.Generics

data Greet = Greet { _msg :: Text }
  deriving (Generic, Show)

instance FromJSON Greet
instance ToJSON Greet

instance ToSample Greet where
  toSample Proxy = Just (encode g)

    where g = Greet &quot;Hello, haskeller!&quot;</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:toSample" class="def">toSample</a> :: <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> a <a href="src/Servant-Docs.html#toSample" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:ToSample" class="caption collapser" onclick="toggleSection('i:ToSample')">Instances</p><div id="section.i:ToSample" class="show"><table><tr><td class="src"><a href="Servant-Docs.html#t:ToSample">ToSample</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:sampleByteString" class="def">sampleByteString</a> :: <span class="keyword">forall</span> a. <a href="Servant-Docs.html#t:ToSample">ToSample</a> a =&gt; <a href="Servant.html#t:Proxy">Proxy</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> <a href="src/Servant-Docs.html#sampleByteString" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ToParam" class="def">ToParam</a> t <span class="keyword">where</span> <a href="src/Servant-Docs.html#ToParam" class="link">Source</a></p><div class="doc"><p>The class that helps us automatically get documentation
   for GET parameters.</p><p>Example of an instance:</p><pre>instance ToParam (QueryParam &quot;capital&quot; Bool) where
  toParam _ =
    DocQueryParam &quot;capital&quot;
                  [&quot;true&quot;, &quot;false&quot;]
                  &quot;Get the greeting message in uppercase (true) or not (false). Default is false.&quot;</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:toParam" class="def">toParam</a> :: <a href="Servant.html#t:Proxy">Proxy</a> t -&gt; <a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a> <a href="src/Servant-Docs.html#toParam" class="link">Source</a></p></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ToCapture" class="def">ToCapture</a> c <span class="keyword">where</span> <a href="src/Servant-Docs.html#ToCapture" class="link">Source</a></p><div class="doc"><p>The class that helps us automatically get documentation
   for URL captures.</p><p>Example of an instance:</p><pre>instance ToCapture (Capture &quot;name&quot; Text) where
  toCapture _ = DocCapture &quot;name&quot; &quot;name of the person to greet&quot;</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:toCapture" class="def">toCapture</a> :: <a href="Servant.html#t:Proxy">Proxy</a> c -&gt; <a href="Servant-Docs.html#t:DocCapture">DocCapture</a> <a href="src/Servant-Docs.html#toCapture" class="link">Source</a></p></div></div><h1 id="g:3">ADTs to represent an <code><a href="Servant-Docs.html#t:API">API</a></code></h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Method" class="def">Method</a> <a href="src/Servant-Docs.html#Method" class="link">Source</a></p><div class="doc"><p>Supported HTTP request methods</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DocDELETE" class="def">DocDELETE</a></td><td class="doc"><p>the DELETE method</p></td></tr><tr><td class="src"><a name="v:DocGET" class="def">DocGET</a></td><td class="doc"><p>the GET method</p></td></tr><tr><td class="src"><a name="v:DocPOST" class="def">DocPOST</a></td><td class="doc"><p>the POST method</p></td></tr><tr><td class="src"><a name="v:DocPUT" class="def">DocPUT</a></td><td class="doc"><p>the PUT method</p></td></tr></table></div><div class="subs instances"><p id="control.i:Method" class="caption collapser" onclick="toggleSection('i:Method')">Instances</p><div id="section.i:Method" class="show"><table><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Eq.html#t:Eq">Eq</a> <a href="Servant-Docs.html#t:Method">Method</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Text-Show.html#t:Show">Show</a> <a href="Servant-Docs.html#t:Method">Method</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Generics.html#t:Generic">Generic</a> <a href="Servant-Docs.html#t:Method">Method</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="https://hackage.haskell.org/package/hashable-1.2.2.0/docs/Data-Hashable.html#t:Hashable">Hashable</a> <a href="Servant-Docs.html#t:Method">Method</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Generics.html#t:Rep">Rep</a> <a href="Servant-Docs.html#t:Method">Method</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Endpoint" class="def">Endpoint</a> <a href="src/Servant-Docs.html#Endpoint" class="link">Source</a></p><div class="doc"><p>An <code><a href="Servant-Docs.html#t:Endpoint">Endpoint</a></code> type that holds the <code><a href="Servant-Docs.html#v:path">path</a></code> and the <code><a href="Servant-Docs.html#v:method">method</a></code>.</p><p>Gets used as the key in the <code><a href="Servant-Docs.html#t:API">API</a></code> hashmap. Modify <code><a href="Servant-Docs.html#v:defEndpoint">defEndpoint</a></code>
 or any <code><a href="Servant-Docs.html#t:Endpoint">Endpoint</a></code> value you want using the <code><a href="Servant-Docs.html#v:path">path</a></code> and <code><a href="Servant-Docs.html#v:method">method</a></code>
 lenses to tweak.</p><pre>&#955;&gt; <code><a href="Servant-Docs.html#v:defEndpoint">defEndpoint</a></code>
GET /
&#955;&gt; <code><a href="Servant-Docs.html#v:defEndpoint">defEndpoint</a></code> &amp; <code><a href="Servant-Docs.html#v:path">path</a></code> <code><a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Setter.html#v:-60--62--126-">&lt;&gt;~</a></code> &quot;foo&quot;
GET /foo
&#955;&gt; <code><a href="Servant-Docs.html#v:defEndpoint">defEndpoint</a></code> &amp; <code><a href="Servant-Docs.html#v:path">path</a></code> <code><a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Setter.html#v:-60--62--126-">&lt;&gt;~</a></code> &quot;foo&quot; &amp; <code><a href="Servant-Docs.html#v:method">method</a></code> <code><a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Setter.html#v:.-126-">.~</a></code> <code><a href="Servant-Docs.html#v:DocPOST">DocPOST</a></code>
POST /foo
</pre></div><div class="subs instances"><p id="control.i:Endpoint" class="caption collapser" onclick="toggleSection('i:Endpoint')">Instances</p><div id="section.i:Endpoint" class="show"><table><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Eq.html#t:Eq">Eq</a> <a href="Servant-Docs.html#t:Endpoint">Endpoint</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Text-Show.html#t:Show">Show</a> <a href="Servant-Docs.html#t:Endpoint">Endpoint</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Generics.html#t:Generic">Generic</a> <a href="Servant-Docs.html#t:Endpoint">Endpoint</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="https://hackage.haskell.org/package/hashable-1.2.2.0/docs/Data-Hashable.html#t:Hashable">Hashable</a> <a href="Servant-Docs.html#t:Endpoint">Endpoint</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Generics.html#t:Rep">Rep</a> <a href="Servant-Docs.html#t:Endpoint">Endpoint</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:path" class="def">path</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Endpoint">Endpoint</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a> <a href="src/Servant-Docs.html#path" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:method" class="def">method</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Endpoint">Endpoint</a> <a href="Servant-Docs.html#t:Method">Method</a> <a href="src/Servant-Docs.html#method" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:defEndpoint" class="def">defEndpoint</a> :: <a href="Servant-Docs.html#t:Endpoint">Endpoint</a> <a href="src/Servant-Docs.html#defEndpoint" class="link">Source</a></p><div class="doc"><p>An <code><a href="Servant-Docs.html#t:Endpoint">Endpoint</a></code> whose path is `&quot;/&quot;` and whose method is <code><a href="Servant-Docs.html#v:DocGET">DocGET</a></code></p><p>Here's how you can modify it:</p><pre>&#955;&gt; <code><a href="Servant-Docs.html#v:defEndpoint">defEndpoint</a></code>
GET /
&#955;&gt; <code><a href="Servant-Docs.html#v:defEndpoint">defEndpoint</a></code> &amp; <code><a href="Servant-Docs.html#v:path">path</a></code> <code><a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Setter.html#v:-60--62--126-">&lt;&gt;~</a></code> &quot;foo&quot;
GET /foo
&#955;&gt; <code><a href="Servant-Docs.html#v:defEndpoint">defEndpoint</a></code> &amp; <code><a href="Servant-Docs.html#v:path">path</a></code> <code><a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Setter.html#v:-60--62--126-">&lt;&gt;~</a></code> &quot;foo&quot; &amp; <code><a href="Servant-Docs.html#v:method">method</a></code> <code><a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Setter.html#v:.-126-">.~</a></code> <code><a href="Servant-Docs.html#v:DocPOST">DocPOST</a></code>
POST /foo
</pre></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:API" class="def">API</a> = <a href="https://hackage.haskell.org/package/unordered-containers-0.2.5.1/docs/Data-HashMap-Strict.html#t:HashMap">HashMap</a> <a href="Servant-Docs.html#t:Endpoint">Endpoint</a> <a href="Servant-Docs.html#t:Action">Action</a> <a href="src/Servant-Docs.html#API" class="link">Source</a></p><div class="doc"><p>Our API type, a good old hashmap from <code><a href="Servant-Docs.html#t:Endpoint">Endpoint</a></code> to <code><a href="Servant-Docs.html#t:Action">Action</a></code></p></div></div><div class="top"><p class="src"><a name="v:emptyAPI" class="def">emptyAPI</a> :: <a href="Servant-Docs.html#t:API">API</a> <a href="src/Servant-Docs.html#emptyAPI" class="link">Source</a></p><div class="doc"><p>An empty <code><a href="Servant-Docs.html#t:API">API</a></code></p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:DocCapture" class="def">DocCapture</a> <a href="src/Servant-Docs.html#DocCapture" class="link">Source</a></p><div class="doc"><p>A type to represent captures. Holds the name of the capture
   and a description.</p><p>Write a <code><a href="Servant-Docs.html#t:ToCapture">ToCapture</a></code> instance for your captured types.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DocCapture" class="def">DocCapture</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_capSymbol" class="def">_capSymbol</a> :: <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:_capDesc" class="def">_capDesc</a> :: <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:DocCapture" class="caption collapser" onclick="toggleSection('i:DocCapture')">Instances</p><div id="section.i:DocCapture" class="show"><table><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Eq.html#t:Eq">Eq</a> <a href="Servant-Docs.html#t:DocCapture">DocCapture</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Text-Show.html#t:Show">Show</a> <a href="Servant-Docs.html#t:DocCapture">DocCapture</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:capSymbol" class="def">capSymbol</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:DocCapture">DocCapture</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a> <a href="src/Servant-Docs.html#capSymbol" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:capDesc" class="def">capDesc</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:DocCapture">DocCapture</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a> <a href="src/Servant-Docs.html#capDesc" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:DocQueryParam" class="def">DocQueryParam</a> <a href="src/Servant-Docs.html#DocQueryParam" class="link">Source</a></p><div class="doc"><p>A type to represent a <em>GET</em> parameter from the Query String. Holds its name,
   the possible values (leave empty if there isn't a finite number of them),
   and a description of how it influences the output or behavior.</p><p>Write a <code><a href="Servant-Docs.html#t:ToParam">ToParam</a></code> instance for your GET parameter types</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DocQueryParam" class="def">DocQueryParam</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_paramName" class="def">_paramName</a> :: <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:_paramValues" class="def">_paramValues</a> :: [<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a>]</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:_paramDesc" class="def">_paramDesc</a> :: <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:_paramKind" class="def">_paramKind</a> :: <a href="Servant-Docs.html#t:ParamKind">ParamKind</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:DocQueryParam" class="caption collapser" onclick="toggleSection('i:DocQueryParam')">Instances</p><div id="section.i:DocQueryParam" class="show"><table><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Eq.html#t:Eq">Eq</a> <a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Text-Show.html#t:Show">Show</a> <a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:ParamKind" class="def">ParamKind</a> <a href="src/Servant-Docs.html#ParamKind" class="link">Source</a></p><div class="doc"><p>Type of GET parameter:</p><ul><li>Normal corresponds to <code>QueryParam</code>, i.e your usual GET parameter</li><li>List corresponds to <code>QueryParams</code>, i.e GET parameters with multiple values</li><li>Flag corresponds to <code>QueryFlag</code>, i.e a value-less GET parameter</li></ul></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Normal" class="def">Normal</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:List" class="def">List</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Flag" class="def">Flag</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:ParamKind" class="caption collapser" onclick="toggleSection('i:ParamKind')">Instances</p><div id="section.i:ParamKind" class="show"><table><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Eq.html#t:Eq">Eq</a> <a href="Servant-Docs.html#t:ParamKind">ParamKind</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Text-Show.html#t:Show">Show</a> <a href="Servant-Docs.html#t:ParamKind">ParamKind</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:paramName" class="def">paramName</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a> <a href="src/Servant-Docs.html#paramName" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:paramValues" class="def">paramValues</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a> [<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a>] <a href="src/Servant-Docs.html#paramValues" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:paramDesc" class="def">paramDesc</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html#t:String">String</a> <a href="src/Servant-Docs.html#paramDesc" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:paramKind" class="def">paramKind</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a> <a href="Servant-Docs.html#t:ParamKind">ParamKind</a> <a href="src/Servant-Docs.html#paramKind" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Response" class="def">Response</a> <a href="src/Servant-Docs.html#Response" class="link">Source</a></p><div class="doc"><p>A type to represent an HTTP response. Has an <code><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Int.html#t:Int">Int</a></code> status and
 a 'Maybe ByteString' response body. Tweak <code><a href="Servant-Docs.html#v:defResponse">defResponse</a></code> using
 the <code><a href="Servant-Docs.html#v:respStatus">respStatus</a></code> and <code><a href="Servant-Docs.html#v:respBody">respBody</a></code> lenses if you want.</p><p>If you want to respond with a non-empty response body, you'll most likely
 want to write a <code><a href="Servant-Docs.html#t:ToSample">ToSample</a></code> instance for the type that'll be represented
 as some JSON in the response.</p><p>Can be tweaked with two lenses.</p><pre>&#955;&gt; defResponse
Response {_respStatus = 200, _respBody = Nothing}
&#955;&gt; defResponse &amp; respStatus .~ 204 &amp; respBody .~ Just &quot;[]&quot;
Response {_respStatus = 204, _respBody = Just &quot;[]&quot;}</pre></div><div class="subs instances"><p id="control.i:Response" class="caption collapser" onclick="toggleSection('i:Response')">Instances</p><div id="section.i:Response" class="show"><table><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Eq.html#t:Eq">Eq</a> <a href="Servant-Docs.html#t:Response">Response</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Text-Show.html#t:Show">Show</a> <a href="Servant-Docs.html#t:Response">Response</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:respStatus" class="def">respStatus</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Response">Response</a> <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Int.html#t:Int">Int</a> <a href="src/Servant-Docs.html#respStatus" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:respBody" class="def">respBody</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Response">Response</a> (<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a>) <a href="src/Servant-Docs.html#respBody" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:defResponse" class="def">defResponse</a> :: <a href="Servant-Docs.html#t:Response">Response</a> <a href="src/Servant-Docs.html#defResponse" class="link">Source</a></p><div class="doc"><p>Default response: status code 200, no response body.</p><p>Can be tweaked with two lenses.</p><pre>&#955;&gt; defResponse
Response {_respStatus = 200, _respBody = Nothing}
&#955;&gt; defResponse &amp; respStatus .~ 204 &amp; respBody .~ Just &quot;[]&quot;
Response {_respStatus = 204, _respBody = Just &quot;[]&quot;}</pre></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Action" class="def">Action</a> <a href="src/Servant-Docs.html#Action" class="link">Source</a></p><div class="doc"><p>A datatype that represents everything that can happen
 at an endpoint, with its lenses:</p><ul><li>List of captures (<code><a href="Servant-Docs.html#v:captures">captures</a></code>)</li><li>List of GET parameters (<code><a href="Servant-Docs.html#v:params">params</a></code>)</li><li>What the request body should look like, if any is requested (<code><a href="Servant-Docs.html#v:rqbody">rqbody</a></code>)</li><li>What the response should be if everything goes well (<code><a href="Servant-Docs.html#v:response">response</a></code>)</li></ul><p>You can tweak an <code><a href="Servant-Docs.html#t:Action">Action</a></code> (like the default <code><a href="Servant-Docs.html#v:defAction">defAction</a></code>) with these lenses
 to transform an action and add some information to it.</p></div><div class="subs instances"><p id="control.i:Action" class="caption collapser" onclick="toggleSection('i:Action')">Instances</p><div id="section.i:Action" class="show"><table><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Eq.html#t:Eq">Eq</a> <a href="Servant-Docs.html#t:Action">Action</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Text-Show.html#t:Show">Show</a> <a href="Servant-Docs.html#t:Action">Action</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:captures" class="def">captures</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Action">Action</a> [<a href="Servant-Docs.html#t:DocCapture">DocCapture</a>] <a href="src/Servant-Docs.html#captures" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:params" class="def">params</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Action">Action</a> [<a href="Servant-Docs.html#t:DocQueryParam">DocQueryParam</a>] <a href="src/Servant-Docs.html#params" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:rqbody" class="def">rqbody</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Action">Action</a> (<a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html#t:ByteString">ByteString</a>) <a href="src/Servant-Docs.html#rqbody" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:response" class="def">response</a> :: <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Type.html#t:Lens-39-">Lens'</a> <a href="Servant-Docs.html#t:Action">Action</a> <a href="Servant-Docs.html#t:Response">Response</a> <a href="src/Servant-Docs.html#response" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:defAction" class="def">defAction</a> :: <a href="Servant-Docs.html#t:Action">Action</a> <a href="src/Servant-Docs.html#defAction" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:single" class="def">single</a> :: <a href="Servant-Docs.html#t:Endpoint">Endpoint</a> -&gt; <a href="Servant-Docs.html#t:Action">Action</a> -&gt; <a href="Servant-Docs.html#t:API">API</a> <a href="src/Servant-Docs.html#single" class="link">Source</a></p><div class="doc"><p>Create an API that's comprised of a single endpoint.
   <code><a href="Servant-Docs.html#t:API">API</a></code> is a <code><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Monoid.html#t:Monoid">Monoid</a></code>, so combine multiple endpoints with
   <code><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Monoid.html#v:mappend">mappend</a></code> or <code><a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Monoid.html#v:-60--62-">&lt;&gt;</a></code>.</p></div></div><h1 id="g:4">Useful modules when defining your own instances</h1><div class="top"><p class="src">module <a href="https://hackage.haskell.org/package/lens-4.6/docs/Control-Lens.html">Control.Lens</a></p></div><div class="top"><p class="src">module <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Monoid.html">Data.Monoid</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.15.0</p></div></body></html>